

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ddot.Ontology &mdash; Data-Driven Ontology Toolkit 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Data-Driven Ontology Toolkit 0.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Data-Driven Ontology Toolkit
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#features">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ontology.html">Analyzing and Manipulating Ontologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utility methods for analysis</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Data-Driven Ontology Toolkit</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ddot.Ontology</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ddot.Ontology</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">multiprocessing</span><span class="o">,</span> <span class="nn">logging</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">scipy</span><span class="o">,</span> <span class="nn">scipy.sparse</span><span class="o">,</span> <span class="nn">igraph</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">hypergeom</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span><span class="p">,</span> <span class="n">STDOUT</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">shlex</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">csr_matrix</span>

<span class="kn">import</span> <span class="nn">ddot</span>
<span class="kn">from</span> <span class="nn">ddot</span> <span class="k">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">ddot.utils</span> <span class="k">import</span> <span class="n">time_print</span><span class="p">,</span> <span class="n">set_node_attributes_from_pandas</span><span class="p">,</span> <span class="n">nx_to_NdexGraph</span><span class="p">,</span> <span class="n">parse_ndex_uuid</span><span class="p">,</span> <span class="n">make_index</span><span class="p">,</span> <span class="n">update_nx_with_alignment</span> 

<span class="n">GENE_TERM_ATTR</span> <span class="o">=</span> <span class="s1">&#39;Gene_or_Term&#39;</span>

<div class="viewcode-block" id="read_alignment_file"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.read_alignment_file">[docs]</a><span class="k">def</span> <span class="nf">read_alignment_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;Term_1&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses an alignment file created from alignOntology&#39;s calculateFDRs script</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    f : str</span>
<span class="sd">       Filename of alignment file</span>

<span class="sd">    source : str </span>
<span class="sd">       Indicates which ontology will be the index of the</span>
<span class="sd">       returned pandas.DataFrame. Value must be either &#39;Term_1&#39; (first</span>
<span class="sd">       ontology) or &#39;Term_2&#39; (second ontology)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    : pandas.DataFrame</span>
<span class="sd">       DataFrame with four columns: &#39;Term&#39;, &#39;Similarity&#39;, &#39;FDR&#39;, and &#39;Size&#39;.</span>
<span class="sd">       The index of the DataFrame are the names of terms in the &quot;source&quot; ontology. </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Five columns in the input file</span>
    <span class="c1"># 1) Term from first &quot;computed&quot; ontology</span>
    <span class="c1"># 2) Term from second &quot;reference&quot; ontology</span>
    <span class="c1"># 3) Similarity value</span>
    <span class="c1"># 4) FDR</span>
    <span class="c1"># 5) Size of the term in the first ontology</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
                       <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Term_1&#39;</span><span class="p">,</span> <span class="s1">&#39;Term_2&#39;</span><span class="p">,</span> <span class="s1">&#39;Similarity&#39;</span><span class="p">,</span> <span class="s1">&#39;FDR&#39;</span><span class="p">,</span> <span class="s1">&#39;Size&#39;</span><span class="p">],</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Term_1&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span>
                              <span class="s1">&#39;Term_2&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span>
                              <span class="s1">&#39;Similarity&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="s1">&#39;FDR&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="s1">&#39;Size&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">},</span>
                       <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39;Term_2&#39;</span> <span class="k">if</span> <span class="n">source</span><span class="o">==</span><span class="s1">&#39;Term_1&#39;</span> <span class="k">else</span> <span class="s1">&#39;Term_1&#39;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">target</span> <span class="p">:</span> <span class="s1">&#39;Term&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;Term&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="align_hierarchies"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.align_hierarchies">[docs]</a><span class="k">def</span> <span class="nf">align_hierarchies</span><span class="p">(</span><span class="n">hier1</span><span class="p">,</span>
                      <span class="n">hier2</span><span class="p">,</span>
                      <span class="n">iterations</span><span class="p">,</span>
                      <span class="n">threads</span><span class="p">,</span>
                      <span class="n">calculateFDRs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Align two hierarchies using alignOntology&#39;s calculateFDRs script</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    hier1 : ddot.Ontology.Ontology</span>
<span class="sd">       First ontology</span>

<span class="sd">    hier2</span>
<span class="sd">       Second ontology</span>

<span class="sd">    iterations : int</span>
<span class="sd">       Number of randomized iterations</span>

<span class="sd">    threads : int</span>
<span class="sd">       Number of CPU threads</span>

<span class="sd">    calculateFDRs : str</span>

<span class="sd">       Filename of calculateFDRs script from alignOntology package. If</span>
<span class="sd">       None, then it is inferred based on ddot.config.</span>
<span class="sd">       </span>
<span class="sd">    output</span>
<span class="sd">       Filename to write alignment. If None, then don&#39;t write.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">align_hierarchies</span><span class="p">(</span><span class="n">hier1</span><span class="p">,</span> <span class="n">hier2</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span>
                                     <span class="n">output</span><span class="o">=</span><span class="n">output_file</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                     <span class="n">calculateFDRs</span><span class="o">=</span><span class="n">calculateFDRs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="n">hier</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hier</span><span class="p">,</span> <span class="n">Ontology</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">hier</span><span class="o">.</span><span class="n">to_3col_table</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent_child</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hier</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hier</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">hier</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hier</span>

    <span class="n">hier1</span> <span class="o">=</span> <span class="n">to_file</span><span class="p">(</span><span class="n">hier1</span><span class="p">)</span>
    <span class="n">hier2</span> <span class="o">=</span> <span class="n">to_file</span><span class="p">(</span><span class="n">hier2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">calculateFDRs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">alignOntology</span><span class="p">)</span>
        <span class="n">calculateFDRs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">alignOntology</span><span class="p">,</span> <span class="s1">&#39;calculateFDRs&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">calculateFDRs</span><span class="p">)</span>

    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;tmp&#39;</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{5}</span><span class="s1"> </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> 0.05 criss_cross </span><span class="si">{2}</span><span class="s1"> </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> gene&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
              <span class="n">hier1</span><span class="p">,</span> <span class="n">hier2</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span> <span class="n">calculateFDRs</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;Alignment command:&#39;</span><span class="p">,</span> <span class="n">cmd</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">shlex</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;alignments_FDR_0.1_t_0.1&#39;</span><span class="p">),</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Killing alignment process </span><span class="si">%s</span><span class="s1">. Output: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">output</span><span class="p">))</span>
            <span class="n">p</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>  <span class="c1"># Kill the process</span>

        <span class="k">return</span> <span class="n">read_alignment_file</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>

<div class="viewcode-block" id="read_term_descriptions"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.read_term_descriptions">[docs]</a><span class="k">def</span> <span class="nf">read_term_descriptions</span><span class="p">(</span><span class="n">description_table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read mapping of GO term ID to their term descriptions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    description_table : str</span>
<span class="sd">       Filename of a tab-delimited table with two columns: GO term ID and term description</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : pandas.Series</span>
<span class="sd">       The index is the GO ID and the values are the term descriptions</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">go_descriptions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">description_table</span><span class="p">,</span>
                                    <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Term&#39;</span><span class="p">,</span> <span class="s1">&#39;Term_Description&#39;</span><span class="p">],</span>
                                    <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">go_descriptions</span> <span class="o">=</span> <span class="n">go_descriptions</span><span class="p">[</span><span class="s1">&#39;Term_Description&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">go_descriptions</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">go_descriptions</span></div>

<div class="viewcode-block" id="parse_obo"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.parse_obo">[docs]</a><span class="k">def</span> <span class="nf">parse_obo</span><span class="p">(</span><span class="n">obo</span><span class="p">,</span>
              <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">id2name_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">id2namespace_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">alt_id_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses an OBO file and writes the results into several tables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obo : str</span>

<span class="sd">        Filename of OBO file</span>

<span class="sd">    output_file : str</span>

<span class="sd">        Filename to write table that describes the ontology&#39;s</span>
<span class="sd">        hierarchical structure. The table has four columns: (1) parent</span>
<span class="sd">        term, (2) child term, (3) relation type (e.g. &quot;is_a&quot; or</span>
<span class="sd">        &quot;part_of&quot;), (4) namespace of relation</span>
<span class="sd">        (e.g. &quot;biological_process&quot; or &quot;cellular component&quot;)</span>

<span class="sd">    id2name_file : str</span>

<span class="sd">        Filename to write table of term descriptions.  The table has</span>
<span class="sd">        two columns: (1) Ontology term (e.g. &quot;GO:0000030&quot;), (2)</span>
<span class="sd">        description (e.g. &quot;mannosyltransferase activity&quot;)</span>

<span class="sd">    id2namespace_file : str</span>
<span class="sd">    </span>
<span class="sd">        Filename to write table of term namespaces.  The table has two</span>
<span class="sd">        columns: (1) Ontology term (e.g. &quot;GO:0000030&quot;), (2) namespace</span>
<span class="sd">        of the term (e.g. &quot;biological_process&quot;)</span>

<span class="sd">    alt_id_file : str</span>
<span class="sd">    </span>
<span class="sd">        Filename to write table of alternative Term IDs that are</span>
<span class="sd">        synonyms and refer to the same term. The table has two</span>
<span class="sd">        columns: (1) Primary Term ID, (2) Alternative Term ID</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">## Keywords that screw up parsing:</span>
    <span class="c1"># import, is_anonymous, intersection_of, union_of</span>

    <span class="c1">## Relations</span>
    <span class="c1"># &#39;is_a:&#39;</span>
    <span class="c1"># &#39;relationship: has_part&#39;  # Not in filtered GO</span>
    <span class="c1"># &#39;relationship: occurs_in&#39; # Not in filtered GO</span>
    <span class="c1"># &#39;relationship: part_of&#39;   </span>
    <span class="c1"># &#39;relationship: positively_regulates&#39; </span>
    <span class="c1"># &#39;relationship: negatively_regulates&#39;</span>
    <span class="c1"># &#39;relationship: regulates&#39;</span>
    <span class="c1"># &#39;relationship: results_in&#39; # Not in filtered GO</span>

    <span class="n">stanza</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">id2name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">id2namespace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">alt_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">in_term_stanza</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">default_namespace_exists</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">obo</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># Remove comments</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;[&#39;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;]&#39;</span><span class="p">:</span>
            <span class="c1"># Add last stanza if it was a term stanza.  Include namespace.</span>
            <span class="k">if</span> <span class="n">in_term_stanza</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stanza</span><span class="p">)</span>

            <span class="c1"># Start new term stanza</span>
            <span class="n">stanza</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># Set the default namespace, if it exists</span>
            <span class="k">if</span> <span class="n">default_namespace_exists</span><span class="p">:</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span>
            
            <span class="c1"># In a term stanzo or not</span>
            <span class="n">in_term_stanza</span> <span class="o">=</span> <span class="n">line</span> <span class="o">==</span><span class="s1">&#39;[Term]&#39;</span>

            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
                
        <span class="c1">#if &#39;alt_id:&#39; in line: assert False</span>

        <span class="k">if</span> <span class="s1">&#39;id:&#39;</span> <span class="o">==</span> <span class="n">line</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">curr_term</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">elif</span> <span class="s1">&#39;alt_id:&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">alt_term</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;alt_id:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">alt_id</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">curr_term</span><span class="p">):</span>  <span class="n">alt_id</span><span class="p">[</span><span class="n">curr_term</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alt_term</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>                          <span class="n">alt_id</span><span class="p">[</span><span class="n">curr_term</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">alt_term</span><span class="p">]</span>
            <span class="n">id2name</span><span class="p">[</span><span class="n">alt_term</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="s1">&#39;name:&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;name:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">id2name</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">curr_term</span><span class="p">)</span>
            <span class="n">id2name</span><span class="p">[</span><span class="n">curr_term</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="s1">&#39;is_a:&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;is_a:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">stanza</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">curr_term</span><span class="p">,</span> <span class="s1">&#39;is_a&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s1">&#39;relationship:&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;relationship:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span> <span class="nb">print</span> <span class="n">line</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="n">relation</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">line</span>
            <span class="n">stanza</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">curr_term</span><span class="p">,</span> <span class="n">relation</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s1">&#39;namespace:&#39;</span> <span class="o">==</span> <span class="n">line</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>
            <span class="n">namespace</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;namespace:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">id2namespace</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">curr_term</span><span class="p">)</span>
            <span class="n">id2namespace</span><span class="p">[</span><span class="n">curr_term</span><span class="p">]</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="k">elif</span> <span class="s1">&#39;default-namespace:&#39;</span> <span class="o">==</span> <span class="n">line</span><span class="p">[:</span><span class="mi">18</span><span class="p">]:</span>
            <span class="n">namespace</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;default-namespace:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">default_namespace_exists</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">default_namespace</span> <span class="o">=</span> <span class="n">namespace</span>

    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">id2name</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">id2name_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">id2namespace</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">id2namespace_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">alt_id</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]))</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">alt_id_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="parse_gaf"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.parse_gaf">[docs]</a><span class="k">def</span> <span class="nf">parse_gaf</span><span class="p">(</span><span class="n">gaf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read gene-term annotations from GAF file format:</span>

<span class="sd">    http://geneontology.org/page/go-annotation-file-gaf-format-21</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gaf : str</span>
<span class="sd">        Filename of GAF file</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    A list of 2-tuples (gene, GO term)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gaf_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DB&#39;</span><span class="p">,</span> <span class="s1">&#39;DB Object ID&#39;</span><span class="p">,</span> <span class="s1">&#39;DB Object Symbol&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Qualifier&#39;</span><span class="p">,</span> <span class="s1">&#39;GO ID&#39;</span><span class="p">,</span> <span class="s1">&#39;DB:Reference&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Evidence Code&#39;</span><span class="p">,</span> <span class="s1">&#39;With (or) From&#39;</span><span class="p">,</span> <span class="s1">&#39;Aspect&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;DB Object Name&#39;</span><span class="p">,</span> <span class="s1">&#39;DB Object Synonym&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;DB Object Type&#39;</span><span class="p">,</span> <span class="s1">&#39;Taxon&#39;</span><span class="p">,</span> <span class="s1">&#39;Date&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Assigned By&#39;</span><span class="p">,</span> <span class="s1">&#39;Annotation Extension&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Gene Product Form ID&#39;</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">gaf</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">gaf_columns</span><span class="p">)</span>

    <span class="c1"># Check that all annotations are to UniProtKB protein IDs</span>
    <span class="k">assert</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;DB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;DB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;UniProtKB&#39;</span>    

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;DB Object ID&#39;</span><span class="p">,</span> <span class="s1">&#39;GO ID&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="Ontology"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology">[docs]</a><span class="k">class</span> <span class="nc">Ontology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A Python representation for constructing, analyzing, and</span>
<span class="sd">    manipulating ontologies.</span>

<span class="sd">    This class&#39;s attributes and methods are focused on the ontology&#39;s</span>
<span class="sd">    hierarchical structure, i.e. a directed acyclic graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">hierarchy</span><span class="p">,</span>
                 <span class="n">mapping</span><span class="p">,</span>
                 <span class="n">hierarchy_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parent_child</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">add_root_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">propagate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct an Ontology object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Iterable of (child term, parent term). E.g. list of 2-tuples</span>

<span class="sd">        mapping</span>
<span class="sd">            Iterable of (gene, term) pairs. E.g. list of 2-tuples</span>

<span class="sd">        hierarchy_attr : pandas.DataFrame</span>

<span class="sd">            Meta-data describing (child_term, parent_term)</span>
<span class="sd">            pairs. Suggestion: The index of the DataFrame must be a</span>
<span class="sd">            pandas.MultiIndex, where the first level is the child term</span>
<span class="sd">            and the second level is the parent term.</span>

<span class="sd">        parent_child : bool</span>

<span class="sd">            If True, then the definitions of &lt;hierarchy&gt; and &lt;mapping&gt;</span>
<span class="sd">            are reversed so that they iterate over (parent term, child</span>
<span class="sd">            term) and (term, gene) pairs.</span>
<span class="sd">        </span>
<span class="sd">        propagate : bool</span>

<span class="sd">            Propagate gene-term annotations up the hierarchy</span>

<span class="sd">        add_root_name : bool</span>

<span class="sd">            The name of an artificial root. If there are multiple</span>
<span class="sd">            roots in the ontology, then they are joined into one root</span>
<span class="sd">            with this name. Default: Don&#39;t create this root.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parent_child</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hierarchy</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]</span>
            
        <span class="c1">## Read term-to-term edges        </span>
        <span class="c1"># parent_2_child[&lt;term_name&gt;] --&gt; list of &lt;term_name&gt;&#39;s children terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> \
                           <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span>
                                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                             <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>

        <span class="k">if</span> <span class="n">add_root_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">## Check if there is a single unifying root term of the</span>
            <span class="c1">## ontology. If not, then identify the multiple roots and</span>
            <span class="c1">## join them under an artificial root</span>
            <span class="n">root_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()</span>
            <span class="nb">print</span> <span class="s1">&#39;Unifying </span><span class="si">%s</span><span class="s1"> roots into one super-root&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">root_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">root_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">root_name</span> <span class="o">=</span> <span class="n">add_root_name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="p">[</span><span class="n">root_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_list</span>

        <span class="c1">## Read gene-to-term edges</span>
        <span class="c1"># self.gene_2_term[&lt;gene_name&gt;] --&gt; list of terms that &lt;gene_name&gt; is mapped to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> \
                            <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
                                                     <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                              <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

        <span class="c1">## Check that the set of terms is the same according to</span>
        <span class="c1">## parent_2_child and self.gene_2_term</span>
        <span class="n">terms_A</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                            <span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">terms_B</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms_B</span> <span class="o">-</span> <span class="n">terms_A</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;WARNING: There are </span><span class="si">{}</span><span class="s1"> terms that are annotated to genes but not connected to the rest of the ontology&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms_B</span> <span class="o">-</span> <span class="n">terms_A</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms_A</span> <span class="o">-</span> <span class="n">terms_B</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;WARNING: There are </span><span class="si">{}</span><span class="s1"> terms that have no direct gene annotations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms_A</span> <span class="o">-</span> <span class="n">terms_B</span><span class="p">))</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">terms_A</span> <span class="o">|</span> <span class="n">terms_B</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="c1">## terms_index[&lt;term_name&gt;] --&gt; index in self.terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>

        <span class="c1">## self.genes_index[&lt;gene_name&gt;] --&gt; index in self.genes        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span>

        <span class="c1">## Convert self.gene_2_term to list term indices rather than term names</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_attr</span> <span class="o">=</span> <span class="n">hierarchy_attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">propagate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">propagate_annotations</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_2_parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_2_parent_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_child_2_parent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_2_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_term_2_genes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_term_sizes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_child_2_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read term-to-term edges</span>
<span class="sd">        # child_2_parent[&lt;term_name&gt;] --&gt; list of &lt;term_name&gt;&#39;s parent term names</span>
<span class="sd">        # child_2_parent_indices[&lt;term_name&gt;] --&gt; list of indices of &lt;term_name&gt;&#39;s parent terms</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">cp_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_list</span><span class="p">:</span>
                <span class="n">cp_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cp_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">first</span><span class="p">)</span>

        <span class="n">child_2_parent</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">r</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> 
            <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">cp_pairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">first</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">child_2_parent_indices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">r</span> <span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span> 
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">child_2_parent</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">child_2_parent</span><span class="p">,</span> <span class="n">child_2_parent_indices</span>

<div class="viewcode-block" id="Ontology.get_roots"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_roots">[docs]</a>    <span class="k">def</span> <span class="nf">get_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the root term(s)&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Ontology.to_networkx"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.to_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">gene_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">term_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">spanning_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts Ontology into a NetworkX object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        gene_attr : pandas.DataFrame</span>
<span class="sd">            </span>
<span class="sd">            Meta-data about genes that will be included as node</span>
<span class="sd">            attributes in the NetworkX object.</span>

<span class="sd">        term_attr : pandas.DataFrame</span>
<span class="sd">            </span>
<span class="sd">            Meta-data about term that will be included as node</span>
<span class="sd">            attributes in the NetworkX object.</span>

<span class="sd">        spanning_tree : bool</span>
<span class="sd">        </span>
<span class="sd">            If True, then identify a spanning tree of the DAG. include</span>
<span class="sd">            an edge attribute &quot;Is_Tree_Edge&quot; that indicates</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="c1">#################################</span>
        <span class="c1">### Add nodes and node attributes</span>

        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">])</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">])</span>

        <span class="n">term_sizes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_term_sizes</span><span class="p">(</span><span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">GENE_TERM_ATTR</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Term&#39;</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;Size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">term_sizes</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;isRoot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">GENE_TERM_ATTR</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Gene&#39;</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="s1">&#39;Size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="s1">&#39;isRoot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Identify the root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="s1">&#39;isRoot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">gene_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_node_attributes_from_pandas</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">gene_attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">term_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_node_attributes_from_pandas</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">term_attr</span><span class="p">)</span>
            
        <span class="c1">#################################</span>
        <span class="c1">### Add edges and edge attributes</span>

        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                           <span class="nb">dict</span><span class="p">(</span><span class="n">EdgeType</span><span class="o">=</span><span class="s1">&#39;Gene-Term&#39;</span><span class="p">))</span> \
                          <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]])</span>

        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
                           <span class="nb">dict</span><span class="p">(</span><span class="n">EdgeType</span><span class="o">=</span><span class="s1">&#39;Child-Parent&#39;</span><span class="p">))</span> \
                          <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[])])</span>

        <span class="k">if</span> <span class="n">spanning_tree</span><span class="p">:</span>
            <span class="c1"># Identify a spanning tree</span>
            <span class="n">tree_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tree_edges</span><span class="p">()</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                   <span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">,</span>
                                   <span class="p">{(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="p">:</span> <span class="s1">&#39;Tree&#39;</span> <span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tree_edges</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;Not_Tree&#39;</span>
                                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)})</span>

        <span class="k">return</span> <span class="n">G</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Ontology.from_table"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.from_table">[docs]</a>    <span class="k">def</span> <span class="nf">from_table</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span>
                   <span class="n">table_file</span><span class="p">,</span>
                   <span class="n">is_mapping</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span>
                   <span class="n">parent_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="n">child_col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="n">propagate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create Ontology from a tab-delimited table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table_file : str</span>
<span class="sd">            Filename of table</span>

<span class="sd">        is_mapping : function</span>
<span class="sd">            Function applied on each row to determine if it is </span>

<span class="sd">        parent_col : int</span>
<span class="sd">            Column for parent terms</span>
<span class="sd">        </span>
<span class="sd">        child_col : int</span>
<span class="sd">            Column for child terms and genes</span>

<span class="sd">        propagate : bool</span>
<span class="sd">            If True, then propagate gene-term mappings</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ddot.Ontology.Ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read table</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">table_file</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Get gene-term mappings</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">is_mapping</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="n">child_col</span><span class="p">,</span> <span class="n">parent_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Get term-term hierarchy and attributes</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span> <span class="n">tmp</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="n">child_col</span><span class="p">,</span> <span class="n">parent_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">hierarchy_attr</span> <span class="o">=</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tmp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">child_col</span><span class="p">,</span> <span class="n">parent_col</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">hierarchy_attr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span>
                   <span class="n">mapping</span><span class="p">,</span>
                   <span class="n">parent_child</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">hierarchy_attr</span><span class="o">=</span><span class="n">hierarchy_attr</span><span class="p">,</span>
                   <span class="n">propagate</span><span class="o">=</span><span class="n">propagate</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Ontology.from_NdexGraph"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.from_NdexGraph">[docs]</a>    <span class="k">def</span> <span class="nf">from_NdexGraph</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span>
                       <span class="n">G</span><span class="p">,</span>
                       <span class="n">edgetype_attr</span><span class="o">=</span><span class="s1">&#39;EdgeType&#39;</span><span class="p">,</span>
                       <span class="n">edgetype_value</span><span class="o">=</span><span class="s1">&#39;Gene-Term&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a NdexGraph object to an Ontology object. Gene and terms</span>
<span class="sd">        are distinguished according by a node attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : NdexGraph</span>

<span class="sd">        edgetype_attr : str</span>

<span class="sd">            Name of the edge attribute that distinguishes a (gene,</span>
<span class="sd">            term) pair from a (child term, parent term) pair</span>

<span class="sd">        gene_value : str</span>
<span class="sd">        </span>
<span class="sd">            Value of the edge attribute for (gene, term) pairs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ddot.Ontology.Ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="n">edgetype_attr</span><span class="p">]</span> <span class="o">==</span> <span class="n">edgetype_value</span><span class="p">:</span>
                <span class="n">mapping</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hierarchy</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ontology.collapse_ontology"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.collapse_ontology">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_ontology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>                          
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mhkramer&#39;</span><span class="p">,</span>
                          <span class="n">collapseRedundantNodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">default_relation</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
                          <span class="n">min_term_size</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove redundant and empty terms. When a term T is removed,</span>
<span class="sd">        hierarchical relations are preserved by connecting every child</span>
<span class="sd">        of T with every parent of T. This removal operation has the</span>
<span class="sd">        nice property of being commutative, i.e. the order of removal</span>
<span class="sd">        does not matter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        method</span>

<span class="sd">            If &quot;mhkramer&quot;, then use the collapseRedundantNodes script</span>
<span class="sd">            in the alignOntology package. If &quot;python&quot;, then use an internal Python script</span>

<span class="sd">        propagate</span>
<span class="sd">        </span>
<span class="sd">            If True, propagate annotations beforehand</span>

<span class="sd">        min_term_size : int</span>
<span class="sd">        </span>
<span class="sd">            Remove terms that are below this size</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;mhkramer&#39;</span><span class="p">:</span>
            <span class="c1"># if propagate:</span>
            <span class="c1">#     if verbose: print &#39;Propagating annotations&#39;</span>
            <span class="c1">#     ont = self.propagate_annotations(inplace=False)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     ont = self</span>

            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="k">if</span> <span class="n">collapseRedundantNodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">alignOntology</span><span class="p">)</span>
                <span class="n">collapseRedundantNodes</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">alignOntology</span><span class="p">,</span> <span class="s1">&#39;collapseRedundantNodes&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">collapseRedundantNodes</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">ont</span><span class="o">.</span><span class="n">to_3col_table</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent_child</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_relation</span><span class="o">=</span><span class="s1">u&#39;default&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>                
                <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">collapseRedundantNodes</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="nb">print</span> <span class="s1">&#39;collapse command:&#39;</span><span class="p">,</span> <span class="n">cmd</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">shlex</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
                <span class="n">collapsed</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="kn">from</span> <span class="nn">StringIO</span> <span class="k">import</span> <span class="n">StringIO</span>
            <span class="k">return</span> <span class="n">Ontology</span><span class="o">.</span><span class="n">from_table</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">collapsed</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;python&#39;</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">),</span> <span class="s1">&#39;total nodes&#39;</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;Propagating annotations&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">propagate_annotations</span><span class="p">()</span>

            <span class="n">parity</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                
                <span class="c1"># Calculate a unique hash for every term based on its set of gense</span>
                <span class="n">names_2_idx</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                <span class="n">term_hash</span> <span class="o">=</span> <span class="p">{</span><span class="n">names_2_idx</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g_list</span><span class="p">),</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">g_list</span><span class="p">)))</span>
                             <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">g_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_2_genes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                             <span class="k">if</span> <span class="n">names_2_idx</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">t</span><span class="p">)}</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Identify nodes to collapse&#39;</span><span class="p">)</span>
                <span class="n">node_order</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">topological_sorting</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>

                <span class="n">small_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_order</span> <span class="k">if</span> <span class="n">term_hash</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_term_size</span><span class="p">]</span>

                <span class="c1"># Terms that have the same set of genes as all of its parents</span>

                <span class="n">same_as_parents</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">same_as_children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_order</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">term_hash</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">term_hash</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">))):</span>
                        <span class="n">same_as_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        
                <span class="c1"># same_as_all_parents = [v for v in node_order</span>
                <span class="c1">#                        if (len(g.neighbors(v, mode=&#39;out&#39;))&gt;0 and all(term_hash[v]==term_hash[y] for y in g.neighbors(v, mode=&#39;out&#39;)))]</span>
                <span class="c1"># same_as_all_children = [v for v in node_order</span>
                <span class="c1">#                         if (len(g.neighbors(v, mode=&#39;in&#39;))&gt;0 and all(term_hash[v]==term_hash[y] for y in g.neighbors(v, mode=&#39;in&#39;)))]</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> empty terms, </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">) terms that are redundant with all their parents (children)&#39;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">small_terms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_as_parents</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_as_children</span><span class="p">)))</span>

                <span class="n">to_delete</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">small_terms</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">same_as_children</span> <span class="k">if</span> <span class="n">parity</span> <span class="k">else</span> <span class="n">same_as_parents</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Collapsing </span><span class="si">%s</span><span class="s1"> empty terms and </span><span class="si">%s</span><span class="s1"> terms that redundant with its </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> \
                               <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">small_terms</span><span class="p">),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">same_as_all_children</span><span class="p">)</span> <span class="k">if</span> <span class="n">parity</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_as_all_parents</span><span class="p">),</span>
                                <span class="s1">&#39;children&#39;</span> <span class="k">if</span> <span class="n">parity</span> <span class="k">else</span> <span class="s1">&#39;parents&#39;</span><span class="p">))</span>
                <span class="n">parity</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">parity</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_delete</span><span class="p">:</span>
                        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_node</span><span class="p">(</span><span class="n">g</span><span class="p">,</span>
                                               <span class="n">v</span><span class="p">,</span>
                                               <span class="n">use_v_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">fast_collapse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span>

            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="n">relation_eq</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="s1">&#39;relation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_relation</span>

            <span class="n">remaining_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">Ontology</span><span class="p">(</span><span class="n">g</span><span class="p">,</span>
                            <span class="n">mapping_file</span><span class="o">=</span><span class="p">[(</span><span class="n">gene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> 
                                          <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                                          <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">remaining_terms</span><span class="p">],</span>
                            <span class="n">combined_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parent_child</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
    
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Ontology.mutual_collapse"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.mutual_collapse">[docs]</a>    <span class="k">def</span> <span class="nf">mutual_collapse</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ont1</span><span class="p">,</span> <span class="n">ont2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collapses two ontologies to the common set of genes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ont1 : ddot.Ontology.Ontology</span>

<span class="sd">        ont2 : ddot.Ontology.Ontology</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ont1_collapsed : ddot.Ontology.Ontology</span>

<span class="sd">        ont2_collapsed : ddot.Ontology.Ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">common_genes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ont1</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">ont2</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Common genes:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_genes</span><span class="p">))</span>

        <span class="n">ont1</span> <span class="o">=</span> <span class="n">ont1</span><span class="o">.</span><span class="n">delete_genes</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ont1</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_genes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># print &#39;Ont1 deleted:&#39;, ont1.summary()</span>
        <span class="n">ont1_collapsed</span> <span class="o">=</span> <span class="n">ont1</span><span class="o">.</span><span class="n">collapse_ontology</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;mhkramer&#39;</span><span class="p">)</span>
        <span class="c1"># print &#39;Ont2 specific genes:&#39;, set(ont2.genes) - common_genes</span>
        <span class="c1"># print &#39;ont2 genes:&#39;, ont2.genes[:5]</span>
        <span class="c1"># print &#39;common genes:&#39;, list(common_genes)[:5]</span>
        <span class="n">ont2</span> <span class="o">=</span> <span class="n">ont2</span><span class="o">.</span><span class="n">delete_genes</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ont2</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_genes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># print &#39;Ont2 deleted:&#39;, ont2.summary()</span>
        <span class="n">ont2_collapsed</span> <span class="o">=</span> <span class="n">ont2</span><span class="o">.</span><span class="n">collapse_ontology</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;mhkramer&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;ont1_collapsed:&#39;</span><span class="p">,</span> <span class="n">ont1_collapsed</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
            <span class="nb">print</span> <span class="s1">&#39;ont2_collapsed:&#39;</span><span class="p">,</span> <span class="n">ont2_collapsed</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ont1_collapsed</span><span class="p">,</span> <span class="n">ont2_collapsed</span></div>

    <span class="k">def</span> <span class="nf">delete_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms_to_delete</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">terms_to_delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">terms_to_delete</span><span class="p">)</span>
        <span class="n">tmp_gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="p">[</span><span class="n">ont</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">terms</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terms_to_delete</span><span class="p">]</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">terms_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="p">[</span><span class="n">ont</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terms_to_delete</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">tmp_gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">parent_2_child</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span> <span class="p">:</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_list</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terms_to_delete</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_list</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                              <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terms_to_delete</span><span class="p">}</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ont</span>

<div class="viewcode-block" id="Ontology.delete_genes"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.delete_genes">[docs]</a>    <span class="k">def</span> <span class="nf">delete_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genes_to_delete</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete genes from ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">genes_to_delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">genes_to_delete</span><span class="p">)</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">genes</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genes_to_delete</span><span class="p">]</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">genes_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="n">t</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                           <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">genes_to_delete</span><span class="p">}</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ont</span></div>
        
<div class="viewcode-block" id="Ontology.rename"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">genes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">terms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">gene_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">term_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename gene and/or term names. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        genes : dict</span>

<span class="sd">           Dictionary mapping current gene names to new names. If</span>
<span class="sd">           specified, genes not in dictionary are deleted.</span>

<span class="sd">        terms : dict</span>

<span class="sd">           Dictionary mapping current term names to new names. If</span>
<span class="sd">           specified, terms not in dictionary are deleted.</span>

<span class="sd">        gene_prefix : str</span>
<span class="sd">        </span>
<span class="sd">           Prefix to append to every gene&#39;s name</span>

<span class="sd">        term_prefix : str</span>
<span class="sd">           </span>
<span class="sd">           Prefix to append to every term&#39;s name</span>

<span class="sd">        inplace : bool</span>

<span class="sd">           If True, then manipulate this Ontology. If False, create a</span>
<span class="sd">           new Ontology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ddot.Ontology.Ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">term_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">terms</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">term_prefix</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">gene_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">genes</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">genes</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gene_prefix</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">genes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">delete_genes</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">genes</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">genes</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">g</span><span class="p">)],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">new_genes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_gene_2_term</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">genes</span><span class="p">:</span>
                <span class="n">new_g</span> <span class="o">=</span> <span class="n">genes</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_g</span><span class="p">,</span> <span class="p">(</span><span class="n">unicode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">new_genes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_g</span><span class="p">)</span>
                    <span class="n">new_gene_2_term</span><span class="p">[</span><span class="n">new_g</span><span class="p">]</span> <span class="o">=</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_g</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">new_gg</span> <span class="ow">in</span> <span class="n">new_g</span><span class="p">:</span>
                        <span class="n">new_genes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_gg</span><span class="p">)</span>
                        <span class="n">new_gene_2_term</span><span class="p">[</span><span class="n">new_gg</span><span class="p">]</span> <span class="o">=</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">genes</span> <span class="o">=</span> <span class="n">new_genes</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="n">new_gene_2_term</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">genes_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

            <span class="c1"># ont.genes = [genes[g] for g in ont.genes]</span>
            <span class="c1"># ont.genes_index = make_index(ont.genes)</span>
            <span class="c1"># ont.gene_2_term = {genes[g] : t for g, t in ont.gene_2_term.items()}</span>
        <span class="k">if</span> <span class="n">terms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">delete_terms</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">terms</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">terms</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">terms</span><span class="p">]</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">terms_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">parent_2_child</span> <span class="o">=</span> <span class="p">{</span><span class="n">terms</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="n">terms</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_list</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_list</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">ont</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ont</span></div>

<div class="viewcode-block" id="Ontology.to_pandas"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.to_pandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">term_2_term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">gene_2_term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">default_relation</span><span class="o">=</span><span class="s1">u&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert Ontology to pandas.DataFrame</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        term_2_term : bool</span>

<span class="sd">            Include (child term, parent term) pairs</span>

<span class="sd">        gene_2_term : bool</span>

<span class="sd">            Include (gene, term) pairs</span>

<span class="sd">        default_relation : str</span>
<span class="sd">        </span>
<span class="sd">            The relation type assigned to all (child term, parent term) pairs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : pandas.DataFrame</span>

<span class="sd">            Three columns: (1) Parent (2) Child -- a gene or child</span>
<span class="sd">            term, (3) Relation type.  The relation type of all (gene,</span>
<span class="sd">            term) pairs is &quot;gene&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parent&#39;</span><span class="p">,</span><span class="s1">&#39;Child&#39;</span><span class="p">,</span><span class="s1">&#39;Relation&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">term_2_term</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_to_pandas</span><span class="p">(</span><span class="n">default_relation</span><span class="p">),</span>
                           <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gene_2_term</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping_to_pandas</span><span class="p">()</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Gene&#39;</span><span class="p">:</span><span class="s1">&#39;Child&#39;</span><span class="p">,</span> <span class="s1">&#39;Term&#39;</span><span class="p">:</span><span class="s1">&#39;Parent&#39;</span><span class="p">},</span>
                       <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;Relation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gene&#39;</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

    <span class="k">def</span> <span class="nf">_hierarchy_to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_relation</span><span class="o">=</span><span class="s1">u&#39;default&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;relation_dict&#39;</span><span class="p">):</span>
            <span class="n">relation_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">relation_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">triples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">relation_dict</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">default_relation</span><span class="p">))</span> \
                   <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_list</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">triples</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parent&#39;</span><span class="p">,</span> <span class="s1">&#39;Child&#39;</span><span class="p">,</span> <span class="s1">&#39;Relation&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">_mapping_to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Gene&#39;</span><span class="p">,</span> <span class="s1">&#39;Term&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df</span>

<div class="viewcode-block" id="Ontology.to_3col_table"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.to_3col_table">[docs]</a>    <span class="k">def</span> <span class="nf">to_3col_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">output</span><span class="p">,</span>
                      <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">parent_child</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">default_relation</span><span class="o">=</span><span class="s1">u&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write Ontology to tab-delimited table with 3 columns and 2 types of rows:</span>

<span class="sd">        Row Type A. Parent term, child term, ontology relation </span>
<span class="sd">           e.g. &quot;GO:0007005      GO:0007006      is_a&quot;</span>
<span class="sd">        Row Type B. Term, gene, &quot;gene&quot;</span>
<span class="sd">           e.g. &quot;GO:0007005      ATG7    gene&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output : str</span>
<span class="sd">            Filename of table</span>

<span class="sd">        header : bool</span>
<span class="sd">            If True, include a header line in the table</span>

<span class="sd">        parent_child : bool</span>
<span class="sd">            If False, then the first and second columns switch places</span>

<span class="sd">        encoding</span>
<span class="sd">            Character encoding</span>

<span class="sd">        default_relation : str</span>
<span class="sd">            </span>
<span class="sd">            Relation type for all (child term, parent term)</span>
<span class="sd">            pairs. Note that the relation type for (gene, term) pairs</span>
<span class="sd">            is &quot;gene&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">(</span><span class="n">default_relation</span><span class="o">=</span><span class="n">default_relation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent_child</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Parent&#39;</span><span class="p">,</span><span class="s1">&#39;Child&#39;</span><span class="p">,</span><span class="s1">&#39;Relation&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Child&#39;</span><span class="p">,</span><span class="s1">&#39;Parent&#39;</span><span class="p">,</span><span class="s1">&#39;Relation&#39;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ontology.copy"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the Ontology object&quot;&quot;&quot;</span>

        <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_list</span><span class="p">]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">[(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Ontology</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
                        <span class="n">hierarchy_attr</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_attr</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">parent_child</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ontology.transitive_closure"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.transitive_closure">[docs]</a>    <span class="k">def</span> <span class="nf">transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the transitive closure on (child term, parent term)</span>
<span class="sd">        relations. Transitivity rules are defined at</span>

<span class="sd">        http://www.geneontology.org/page/ontology-relations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">relations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;is_a&#39;</span><span class="p">,</span> <span class="s1">&#39;regulates&#39;</span><span class="p">,</span> <span class="s1">&#39;positively_regulates&#39;</span><span class="p">,</span> <span class="s1">&#39;negatively_regulates&#39;</span><span class="p">,</span> <span class="s1">&#39;has_part&#39;</span><span class="p">,</span> <span class="s1">&#39;part_of&#39;</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">]</span>
        <span class="n">relations_index</span> <span class="o">=</span> <span class="n">make_index</span><span class="p">(</span><span class="n">relations</span><span class="p">)</span>
        <span class="n">go_reasoning</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">relations</span><span class="p">:</span>
            <span class="n">go_reasoning</span><span class="p">[(</span><span class="s1">&#39;is_a&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">go_reasoning</span><span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;is_a&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="s1">&#39;has_part&#39;</span><span class="p">:</span>
                <span class="n">go_reasoning</span><span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;part_of&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;part_of&#39;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;regulates&#39;</span><span class="p">,</span> <span class="s1">&#39;positively_regulates&#39;</span><span class="p">,</span> <span class="s1">&#39;negatively_regulates&#39;</span><span class="p">]:</span>
            <span class="n">go_reasoning</span><span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;part_of&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;regulates&#39;</span>
        <span class="n">go_reasoning</span><span class="p">[(</span><span class="s1">&#39;has_part&#39;</span><span class="p">,</span> <span class="s1">&#39;has_part&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;has_part&#39;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

        <span class="c1"># Sort from leaves up</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">topological_sorting</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">):</span>
        
            <span class="c1"># Get parents</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">):</span>
                
                <span class="c1"># Infer GO relations of new edges</span>
                <span class="n">base_relation</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)][</span><span class="s1">&#39;relation&#39;</span><span class="p">]</span>

                <span class="c1"># Iterate over grandparents</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">go_reasoning</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">base_relation</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p</span><span class="p">)][</span><span class="s1">&#39;relation&#39;</span><span class="p">]),</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="c1"># If a relation can&#39;t be inferred, then don&#39;t add a new edge</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                            <span class="c1"># Edge already exists, so take the higher-ranked relation</span>
                            <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
                            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;relation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="k">if</span> <span class="n">relations_index</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">relations_index</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;relation&#39;</span><span class="p">]]</span> <span class="k">else</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;relation&#39;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Add new edge with relation</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">relation</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>                                        

        <span class="k">return</span> <span class="n">g</span></div>
        
        <span class="c1">## Update parent_2_child , child_2_parent, child_2_parent_indices</span>
        
<div class="viewcode-block" id="Ontology.semantic_similarity"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.semantic_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">semantic_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">genes_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">term_sizes</span><span class="o">=</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span>
                            <span class="n">between_terms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Resnik&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the semantic similarity between pair of genes in</span>
<span class="sd">        &lt;genes_subset&gt;. Similarity s(g1,g2) is defined as</span>
<span class="sd">        :math:`-log_2(|T_sca| / |T_root|)` where :math:`|T|` is the number of genes in</span>
<span class="sd">        &lt;genes_subset&gt; that are under term T. :math:`T_sca` is the &quot;smallest</span>
<span class="sd">        common ancestor&quot;, the common ancestral term with the smallest</span>
<span class="sd">        term size. :math:`T_root` is the root term of the ontology.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        genes_subset : iterable</span>

<span class="sd">            The set of genfes, over which pairs the similarity will be</span>
<span class="sd">            calculated. If &lt;term_sizes&gt;=&#39;subset&#39;, then term sizes will</span>
<span class="sd">            be recalculated according to only these genes, rather than</span>
<span class="sd">            all genes in the ontology</span>

<span class="sd">        between_terms : bool</span>
<span class="sd">            if True, then output similarity between all terms</span>

<span class="sd">        output : str</span>
<span class="sd">            type of semantic similarity</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If no genes are specified, then compute the similarity between all pairs of genes</span>
        <span class="k">if</span> <span class="n">genes_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">genes_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span>

        <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Calculating term sizes&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">term_sizes</span><span class="o">==</span><span class="s1">&#39;all_genes&#39;</span><span class="p">:</span>
            <span class="n">term_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_term_sizes</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">term_sizes</span><span class="o">==</span><span class="s1">&#39;subset&#39;</span><span class="p">:</span>
            <span class="c1">### Reimplement this by deleting genes</span>

            <span class="c1"># Recompute term sizes, with respect to the intersection of genes</span>
            <span class="n">term_2_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_2_genes</span>
            <span class="n">genes_subset_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">genes_subset</span><span class="p">)</span>
            <span class="n">term_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">term_2_genes</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span> <span class="o">&amp;</span> <span class="n">genes_subset_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">output</span><span class="o">==</span><span class="s1">&#39;Resnik&#39;</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

            <span class="n">sca</span> <span class="o">=</span> <span class="n">get_smallest_ancestor</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">term_sizes</span><span class="p">)</span>
            <span class="n">ss_terms</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">term_sizes</span><span class="p">[</span><span class="n">sca</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">term_sizes</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

            <span class="k">if</span> <span class="n">between_terms</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ss_terms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For convenience below, set the similarity between a term and itself to be 0</span>
                <span class="n">ss_terms</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ss_terms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ss_terms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]]</span> <span class="o">=</span> <span class="mi">0</span>                
                
                <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">genes_subset</span><span class="p">]</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss_terms</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">idx_list</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
                <span class="k">return</span> <span class="n">ss</span>

            <span class="c1"># # Add nodes in the igraph object to represent genes</span>
            <span class="c1"># graph.add_vertices(self.genes)</span>
            <span class="c1"># graph.add_edges([(g, t) for g, t_list in self.gene_2_term.items() for t in t_list])</span>
            <span class="c1"># assert graph.vs[-len(self.genes):][&#39;name&#39;] == self.genes</span>

            <span class="c1"># sca = get_smallest_ancestor(graph, term_sizes)</span>
            <span class="c1"># # Offset the indices</span>
            <span class="c1"># idx = [len(self.terms) + self.genes_index[g] for g in genes_subset]</span>
            <span class="c1"># ss = (-1 * np.log2(term_sizes / float(term_sizes.max())))[sca[idx, :][:, idx][np.triu_indices(len(idx), k=1)]]</span>

            <span class="c1"># return ss</span>
        <span class="k">elif</span> <span class="n">output</span><span class="o">==</span><span class="s1">&#39;sca_list&#39;</span><span class="p">:</span>
            <span class="c1">## For each pair of gene, return a list of the smallest</span>
            <span class="c1">## common ancestors (sca). There may be more than one sca with the same size.</span>

            <span class="n">gene_2_term_numpy</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>            
            <span class="n">common_ancestors</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">gene_2_term_numpy</span><span class="p">[</span><span class="n">g1</span><span class="p">],</span> <span class="n">gene_2_term_numpy</span><span class="p">[</span><span class="n">g2</span><span class="p">],</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> \
                                <span class="k">for</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">genes_subset</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">common_ancestors</span><span class="p">)</span>
            <span class="n">min_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">term_sizes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">common_ancestors</span><span class="p">]</span>
            <span class="n">sca_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">term_sizes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">,</span> <span class="n">min_size</span><span class="p">)]</span>

            <span class="c1"># Dict: (g1,g2) gene pairs --&gt; list of term indices</span>
            <span class="k">return</span> <span class="p">{(</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">),</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">genes_subset</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">sca_list</span><span class="p">)}</span></div>

    <span class="k">def</span> <span class="nf">_get_term_2_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="s1">&#39;Calculating term_2_genes&#39;</span>
        <span class="n">term_2_genes</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span> \
                        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">terms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">],</span>
                                                             <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                      <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term_2_genes</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">term_2_genes</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">term_2_genes</span>

<div class="viewcode-block" id="Ontology.get_term_sizes"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_term_sizes">[docs]</a>    <span class="k">def</span> <span class="nf">get_term_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of term sizes in the same order as self.terms&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">propagate</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propagate_annotations</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">term_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">terms</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">term_sizes</span></div>

<div class="viewcode-block" id="Ontology.shuffle_genes"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.shuffle_genes">[docs]</a>    <span class="k">def</span> <span class="nf">shuffle_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle the names of genes&quot;&quot;&quot;</span>

        <span class="n">new_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="n">rename</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">,</span> <span class="n">new_order</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rename</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ontology.get_tree_edges"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_tree_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_tree_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Identify a spanning tree of the DAG (including genes as part of the</span>
<span class="sd">        DAG), and return a list of (u, v) edges in the tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">(</span><span class="n">include_genes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spanning_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tree_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">tree</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                           <span class="n">tree</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">])</span> 
                          <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">es</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">tree_edges</span></div>

<div class="viewcode-block" id="Ontology.is_dag"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.is_dag">[docs]</a>    <span class="k">def</span> <span class="nf">is_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the Ontology is a valid directed acyclic graph,</span>
<span class="sd">        False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_dag</span><span class="p">()</span></div>

<div class="viewcode-block" id="Ontology.to_igraph"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.to_igraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_igraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_genes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spanning_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert Ontology to an igraph.Graph object. Gene and term names are</span>
<span class="sd">           stored in the &#39;name&#39; vertex attribute of the igraph object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_genes : bool</span>

<span class="sd">           Include genes as vertices in the igraph object.</span>

<span class="sd">        spanning_tree : bool</span>

<span class="sd">            If True, then identify a spanning tree of the DAG. include</span>
<span class="sd">            an edge attribute &quot;Is_Tree_Edge&quot; that indicates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : igraph.Graph</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">include_genes</span><span class="p">:</span>
            <span class="n">terms_index_offset</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span> <span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">terms_index_offset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span>
                      <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span>
                      <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]]</span> <span class="o">+</span>
                     <span class="p">[(</span><span class="n">terms_index_offset</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">terms_index_offset</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> 
                      <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">),</span>
                                 <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
                                 <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span>
                                     <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span>
                                     <span class="n">GENE_TERM_ATTR</span><span class="p">:[</span><span class="s1">&#39;Gene&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Term&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">]</span>
                                 <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">),</span>
                                 <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
                                 <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">spanning_tree</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_term_sizes</span><span class="p">(</span><span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">parent_priority</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">]</span>

            <span class="c1"># Identify spanning tree</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tree_igraph</span><span class="p">(</span>
                <span class="n">graph</span><span class="p">,</span>
                <span class="n">parent_priority</span><span class="o">=</span><span class="n">parent_priority</span><span class="p">,</span>
                <span class="n">optim</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span>
                <span class="n">edge_name</span><span class="o">=</span><span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Tree&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="s1">&#39;Not_Tree&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="Ontology.get_shortest_paths"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_shortest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the length of the shortest paths between all pairs of</span>
<span class="sd">        terms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sparse</span>

<span class="sd">            If True, return a scipy.sparse matrix. If False, return a</span>
<span class="sd">            NumPy array</span>

<span class="sd">        chunk_size</span>

<span class="sd">            Computational optimization: shortest paths are calculated in batches.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d : np.ndarray or scipy.sparse.matrix</span>

<span class="sd">            d[x,y] is the length of the shortest directed path from a</span>
<span class="sd">            descendant term with index x to an ancestral term with</span>
<span class="sd">            index y. Term indices are defined by</span>
<span class="sd">            self.terms_index. d[x,y]=0 if no directed path exists.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span>
                  <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                  <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">,</span>
                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">split_indices_chunk</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">),</span> <span class="n">chunk_size</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Ontology.get_longest_paths"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_longest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_longest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the lengths of the longest directed paths between all pairs</span>
<span class="sd">        of terms.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : np.ndarray</span>

<span class="sd">           NumPy array d where d[x,y] is length of the longest</span>
<span class="sd">           directed path from a descendant term x to an ancestral term y</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ontology.get_connectivity_matrix"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_connectivity_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_connectivity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate which terms are descendants/ancestors of other terms</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        sparse : bool</span>

<span class="sd">            If True, return a scipy.sparse matrix. If False, return a</span>
<span class="sd">            NumPy array</span>

<span class="sd">        Creates a term-by-term matrix d where</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d : np.ndarray or scipy.sparse.matrix</span>

<span class="sd">            d[i,j] is 1 if term i is an ancestor of term j, and 0</span>
<span class="sd">            otherwise. Note that d[i,i] == 1 and d[root,i] == 0, for</span>
<span class="sd">            every i.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Calculating connectivity matrix&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">paths</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]),</span>
                                              <span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">paths</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">])),</span>
                                             <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Ontology.get_connectivity_matrix_nodiag"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_connectivity_matrix_nodiag">[docs]</a>    <span class="k">def</span> <span class="nf">get_connectivity_matrix_nodiag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a similar matrix as in Ontology.get_connectivity_matrix(),</span>
<span class="sd">        but the diagonal of the matrix is 0.</span>

<span class="sd">        Note: !!!!!!!!!!!!!!!!!!!!!!!!</span>
<span class="sd">            d[a, a] == 0 instead of 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connectivity_matrix</span><span class="p">()</span>
        
        <span class="n">d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Ontology.get_leaves"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms_list</span><span class="p">,</span> <span class="n">children_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns terms in &lt;terms_list&gt; that are not ancestors of any term in</span>
<span class="sd">        &lt;children_list&gt;</span>
<span class="sd">        </span>
<span class="sd">        If &lt;children_list&gt; is None, then select the terms in</span>
<span class="sd">        &lt;terms_list&gt; that are not ancestors of any of the other terms</span>
<span class="sd">        in &lt;terms_list&gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">connectivity_matrix_nodiag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connectivity_matrix_nodiag</span><span class="p">()</span>
        
        <span class="n">terms_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">terms_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">children_list</span> <span class="o">=</span> <span class="n">terms_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">children_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">children_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">terms_list</span><span class="p">[</span><span class="o">~</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">connectivity_matrix_nodiag</span><span class="p">[</span><span class="n">children_list</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">terms_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Ontology.propagate_annotations"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.propagate_annotations">[docs]</a>    <span class="k">def</span> <span class="nf">propagate_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span>
                              <span class="n">method</span><span class="o">=</span><span class="s1">&#39;iterative_union&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Propagates gene-term annotations through the ontology&quot;&quot;&quot;</span>
            
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">direction</span><span class="o">==</span><span class="s1">&#39;forward&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;iterative_union&#39;</span><span class="p">:</span>

                <span class="n">child_2_parent_idx</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">ont</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="n">ont</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">p_list</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">child_2_parent</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="n">gene_2_term_set</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">g</span> <span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">t_list</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

                <span class="n">genes_to_update</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes_to_update</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Iterate over a copy of genes_to_update</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">genes_to_update</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
                        <span class="n">curr_terms</span> <span class="o">=</span> <span class="n">gene_2_term_set</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                        <span class="n">num_old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_terms</span><span class="p">)</span>
                        <span class="n">curr_terms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">curr_terms</span> 
                                 <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">child_2_parent_idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[])]))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_terms</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_old</span><span class="p">:</span>
                            <span class="n">genes_to_update</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>                        

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="n">count</span><span class="p">,</span>
                    <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;ERROR: Ontology depth &gt;1000. Stopping in case of bug in code&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span>
                <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_set</span> <span class="ow">in</span> <span class="n">gene_2_term_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ancestor_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ont</span><span class="o">.</span><span class="n">get_connectivity_matrix</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="p">:</span> <span class="n">ancestor_matrix</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ont</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_fields</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">direction</span><span class="o">==</span><span class="s1">&#39;backward&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unsupported propagation direction: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">direction</span><span class="p">)</span>

            <span class="c1"># print &#39;WARNING: assumes that annotations are already forward propagated&#39;</span>

            <span class="c1"># parent_2_children_idx = {ont.terms_index[p] : [ont.terms_index[c] for c in c_list] for p, c_list in ont.parent_2_child.items()}</span>
            <span class="c1"># gene_2_term_set = {g : set(t_list) for g, t_list in ont.gene_2_term.items()}</span>

            <span class="c1"># graph = ont.to_igraph()</span>
            <span class="c1"># for parent in graph.vs[graph.topological_sorting(mode=&#39;in&#39;)][&#39;name&#39;]:</span>
            <span class="c1">#     for c in parent_2_children_idx[parent]</span>

            <span class="c1"># ont.gene_2_term = {g : sorted(t_set) for g, t_set in gene_2_term_set.items()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unsupported propagation direction: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">direction</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ont</span></div>

<div class="viewcode-block" id="Ontology.propagate_ontotypes"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.propagate_ontotypes">[docs]</a>    <span class="k">def</span> <span class="nf">propagate_ontotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ontotypes</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">ontotype_size</span><span class="p">,</span> <span class="n">max_ontotype</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fixed_size&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Propagates a list of base ontotypes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ontotypes</span>

<span class="sd">            An array of ontotypes in scipy.sparse.csr_matrix format.</span>
<span class="sd">            Each row is a separate ontotype.</span>

<span class="sd">        method</span>

<span class="sd">            If &#39;fixed_size&#39;, then the sum of values in every ontotype</span>
<span class="sd">            is exactly the same, namely &lt;ontotype_size&gt;</span>

<span class="sd">        ontotype_size</span>

<span class="sd">            If method==&#39;fixed_size&#39;, then this is the sum of values in</span>
<span class="sd">            every ontotype</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Just return the array</span>
        <span class="k">if</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;genes&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;fixed_size&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ontotype_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ontotypes</span>

                <span class="k">assert</span> <span class="n">ontotype_size</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>        

                <span class="c1">## Each non-zero term in the ontotype is assumed to be hit</span>
                <span class="c1">## by exactly one gene and that term is the only term the</span>
                <span class="c1">## gene hits</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Calculating node ancestry&#39;</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connectivity_matrix</span><span class="p">()</span>

                <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">ontotypes</span><span class="o">.</span><span class="n">dtype</span>

                <span class="c1"># The usage of np.int8 for &lt;d&gt; requires ontotype size be &lt;= 127</span>
                <span class="k">assert</span> <span class="n">ontotype_size</span> <span class="o">&lt;=</span> <span class="mi">127</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Formatting ontotype array&#39;</span><span class="p">)</span>
                <span class="n">ontotype_arr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">ontotypes</span><span class="p">)</span>
                <span class="n">nnz</span> <span class="o">=</span> <span class="n">ontotype_arr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Sanity checks&#39;</span><span class="p">)</span>

                <span class="c1"># # Number of starting perturbations in each ontotype</span>
                <span class="c1"># # Currently supporting only 2</span>
                <span class="c1"># assert ontotype_size==2</span>

                <span class="c1"># Check that the number of non-zero elements in every row is equal ontotype_size</span>
                <span class="k">assert</span><span class="p">(</span> <span class="p">((</span><span class="n">ontotype_arr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ontotype_size</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>

                <span class="c1"># Check that the every consecutive block of &lt;ontotype_size&gt; elements is located in a new row a new row</span>
                <span class="k">assert</span><span class="p">(</span> <span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="n">ontotype_size</span><span class="p">,]</span> <span class="o">!=</span> <span class="nb">range</span><span class="p">(</span><span class="n">ontotype_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>

                <span class="c1"># Check that the non-zero elements were returned in the order of traversing row-by-row</span>
                <span class="k">assert</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">ontotype_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Check that the number of non-zero elements is a multiple of ontotype_size</span>
                <span class="k">assert</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="n">ontotype_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>

                <span class="c1"># import pdb</span>
                <span class="c1"># pdb.set_trace()</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Doing propagation&#39;</span><span class="p">)</span>
                <span class="c1"># For all ontotypes, calculate the propagation of the</span>
                <span class="c1"># first term perturbed as an array, and likewise for the</span>
                <span class="c1"># second term.  Then, add the arrays.</span>

                <span class="k">if</span> <span class="n">ontotype_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Matrix for propagating the first perturbed term</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ontotype_arr</span><span class="p">[(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="mi">2</span><span class="p">],</span>
                                                          <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="mi">2</span><span class="p">])]),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Matrix for propagating the second perturbed term</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ontotype_arr</span><span class="p">[(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="mi">2</span><span class="p">],</span>
                                                          <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="mi">2</span><span class="p">])]),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Since the we&#39;re propagating genes, we need to limit the ontotype value</span>
                    <span class="n">ontotype_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">max_ontotype</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">ontotype_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ontotype_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ontotype_arr</span><span class="p">[(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nnz</span><span class="p">[</span><span class="mi">1</span><span class="p">])]),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="k">assert</span> <span class="p">(</span><span class="n">ontotype_arr</span> <span class="o">&gt;</span> <span class="n">max_ontotype</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">ontotype_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ontotype_arr</span><span class="p">,</span> <span class="n">max_ontotype</span><span class="p">)</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ontotype_arr</span>

            <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;topological&#39;</span><span class="p">:</span>

                <span class="k">assert</span> <span class="n">ontotypes</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span>
                <span class="k">if</span> <span class="n">ontotypes</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">:</span> <span class="k">assert</span> <span class="n">max_ontotype</span> <span class="o">&lt;=</span> <span class="mi">127</span>
                
                <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">ontotypes</span><span class="p">):</span>
                    <span class="n">ontotypes</span> <span class="o">=</span> <span class="n">ontotypes</span><span class="o">.</span><span class="n">toarray</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ontotypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ontotypes</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

                <span class="c1"># Topological sort on terms, going bottom-up the ontology</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span><span class="o">.</span><span class="n">topological_sorting</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">):</span>
                    
                    <span class="c1"># Add the values from child to all its parents.</span>
                    <span class="c1"># Cap the value at &lt;max_ontotype&gt;.  When</span>
                    <span class="c1"># propagating the gene-term annotations in an</span>
                    <span class="c1"># ontology, you should set max_ontotype=1.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_2_parent_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                        <span class="n">parents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_2_parent_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

                        <span class="n">ontotypes</span><span class="p">[:,</span> <span class="n">parents</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">max_ontotype</span><span class="p">,</span>
                                                           <span class="n">ontotypes</span><span class="p">[:,</span> <span class="n">parents</span><span class="p">]</span> <span class="o">+</span> <span class="n">ontotypes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ontotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ontotypes</span> <span class="o">&lt;=</span> <span class="n">max_ontotype</span><span class="p">):</span>
                            <span class="nb">print</span> <span class="n">i</span>
                            <span class="k">assert</span> <span class="kc">False</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ontotypes</span> <span class="o">&lt;=</span> <span class="n">max_ontotype</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">ontotypes</span></div>

<div class="viewcode-block" id="Ontology.get_ontotype"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_ontotype">[docs]</a>    <span class="k">def</span> <span class="nf">get_ontotype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gset_sample</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;dict&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">gene_ordering</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the ontotypes of genotypes. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gset_sample : list</span>

<span class="sd">            List of gene sets (i.e. gsets) A &quot;gset&quot; is a set of genes,</span>
<span class="sd">            represented as a tuple</span>

<span class="sd">        prop : str</span>

<span class="sd">            If &#39;genes&#39;, then the value of a term is the number of</span>
<span class="sd">            genes in the term which are deleted.</span>

<span class="sd">        format : str</span>

<span class="sd">            The data format of the ontotype. Supported formats are</span>
<span class="sd">            &#39;dict&#39;, &#39;scipy.coo&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        If format==&#39;dict&#39;, then return a list, where each element is a</span>
<span class="sd">        dictionary representation of an ontotype.</span>

<span class="sd">        If format==&#39;scipy.coo&#39;, then return a genotype-by-term matrix</span>
<span class="sd">        as a scipy.sparse.coo_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;genes&#39;</span><span class="p">:</span>

            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Creating features&#39;</span><span class="p">)</span>
            <span class="nb">print</span> <span class="nb">format</span><span class="p">,</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;scipy.csr&#39;</span>
            
            <span class="k">if</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;dict&#39;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>                
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">])</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">]</span>                
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span> <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">onto_sample</span><span class="p">]</span>
                
            <span class="k">elif</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;scipy.coo&#39;</span><span class="p">:</span>
                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Making i, j, data&#39;</span><span class="p">)</span>

                <span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">)),</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">)</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">])</span>

                <span class="c1">#ij = np.array([(a, t) for a, gset in enumerate(gset_sample) for g in gset for t in self.gene_2_term[g]])</span>
                <span class="c1">#data = np.ones((ij.shape[0], ))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">))</span>
                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Making sparse COO matrix&#39;</span><span class="p">)</span>
                <span class="c1">#onto_sample = scipy.sparse.coo_matrix((data, (ij[:,0], ij[:,1])), (len(gset_sample), len(self.terms)), dtype=dtype)</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;scipy.csr&#39;</span><span class="p">:</span>
                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Making indices, indptr, data&#39;</span><span class="p">)</span>
                <span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">gset_sample_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gset</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gset_sample_x</span><span class="p">)</span>
                <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">gset</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample_x</span><span class="p">])))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Making sparse CSR matrix&#39;</span><span class="p">)</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;dense&#39;</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="mi">127</span><span class="p">,</span> <span class="s2">&quot;Gset dimension must be &lt;= 127 to create an np.int8 array&quot;</span>

                <span class="c1"># Check that all genes in gset_sample are in gset_2_terms</span>
                <span class="k">assert</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

                <span class="c1"># Convert gene_2_term to a numpy genes-by-terms boolean matrix</span>
                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Creating gene_2_term matrix&#39;</span><span class="p">)</span>
                <span class="n">gene_2_term_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">terms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">gene_2_term_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">terms</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Converting gset_sample into matrix&#39;</span><span class="p">)</span>
                <span class="n">gset_sample_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">]</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">])</span>

                <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Creating gset_2_terms matrix&#39;</span><span class="p">)</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">onto_sample</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">gene_2_term_arr</span><span class="p">,</span>
                                           <span class="n">gset_sample_arr</span><span class="p">[:,</span><span class="n">d</span><span class="p">],</span>
                                           <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Done creating features&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">onto_sample</span>

        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;or&#39;</span><span class="p">:</span>

            <span class="n">onto_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">,</span> <span class="n">prop</span><span class="o">=</span><span class="s1">&#39;genes&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;dict&#39;</span><span class="p">:</span>
                <span class="c1"># Set all values to 1</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">onto_sample</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scipy.coo&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.csr&#39;</span><span class="p">,</span> <span class="s1">&#39;dense&#39;</span><span class="p">]:</span>
                <span class="c1"># Do this to preserve data type of onto_sample,</span>
                <span class="c1"># instead of onto_sample = (onto_sample &gt;= 1), which</span>
                <span class="c1"># would create a boolean</span>
                <span class="n">onto_sample</span><span class="p">[</span> <span class="n">onto_sample</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Format </span><span class="si">%s</span><span class="s1"> not supported for prop&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">prop</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">onto_sample</span>

        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;children&#39;</span><span class="p">:</span>

            <span class="kn">import</span> <span class="nn">igraph</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">collections</span>

            <span class="n">graph</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">Read_Ncol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ontology_prefix</span><span class="p">)</span>
            <span class="n">g_vs_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])}</span>                
            <span class="n">gene_2_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span>
            
            <span class="c1"># For each gset, create a dictionary mapping a perturbed term</span>
            <span class="c1"># (i.e. its index in self.terms) to the number of genes</span>
            <span class="c1"># perturbed</span>
            <span class="n">genes_features</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">([</span><span class="n">term</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">gene_2_term</span><span class="p">[</span><span class="n">g</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">gset</span> <span class="ow">in</span> <span class="n">gset_sample</span><span class="p">]</span>      
            
            <span class="k">for</span> <span class="n">term_count</span> <span class="ow">in</span> <span class="n">genes_features</span><span class="p">:</span>
                <span class="n">parent_perturbations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> \
                                        <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[[</span><span class="n">p</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">term_count</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> \
                                                       <span class="n">p</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">g_vs_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">term</span><span class="p">]],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)]][</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>
                <span class="n">parent_perturbations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">parent_perturbations</span><span class="p">))</span>                    
                <span class="n">term_count</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parent_perturbations</span><span class="p">)</span>
            <span class="n">perturbations</span> <span class="o">=</span> <span class="n">genes_features</span>

            <span class="k">return</span> <span class="n">perturbations</span>

        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;min_cut&#39;</span><span class="p">:</span>
            <span class="c1"># TODO</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not supported&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;gene_identity&#39;</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gset</span><span class="p">]</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">)</span>            
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">))),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">)))</span>

            <span class="k">if</span> <span class="nb">format</span><span class="o">==</span><span class="s1">&#39;scipy.csr&#39;</span><span class="p">:</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">onto_sample</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scipy.coo&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.csr&#39;</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">onto_sample</span>

        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;matrix_mult&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">))</span> <span class="ow">or</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">),</span> <span class="s1">&#39;gset_sample must be a sample-by-gene matrix&#39;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">gene_ordering</span> <span class="o">=</span> <span class="n">gset_sample</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">gset_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">)</span>

            <span class="n">gset_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">)</span>
            <span class="n">annotation_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_annotation_matrix</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">gene_ordering</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gene_ordering</span><span class="p">])</span>
                <span class="n">gset_sample</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">gset_sample</span><span class="p">)[:,</span><span class="n">contained</span><span class="p">])</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gene_ordering</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">g</span><span class="p">)])</span>
                <span class="n">annotation_matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">annotation_matrix</span><span class="p">)[</span><span class="n">subset</span><span class="p">,:])</span>

            <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">gset_sample</span> <span class="o">*</span> <span class="n">annotation_matrix</span>

            <span class="k">if</span> <span class="nb">format</span><span class="o">==</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
                <span class="c1"># Create dataframe</span>
                <span class="n">unused_terms</span> <span class="o">=</span> <span class="p">(</span><span class="n">onto_sample</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="nb">print</span> <span class="s1">&#39;Removing </span><span class="si">%s</span><span class="s1"> terms with no mutations among samples&#39;</span> <span class="o">%</span> <span class="n">unused_terms</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">onto_sample</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">onto_sample</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[:,</span><span class="o">~</span><span class="n">unused_terms</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)[</span><span class="o">~</span><span class="n">unused_terms</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">onto_sample</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid perturbation type&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">format_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;table&#39;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">fmt</span><span class="o">==</span><span class="s1">&#39;table&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">features</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scipy.coo&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.csr&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy.dense&#39;</span><span class="p">]:</span>
            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Getting element indices for sparse representation&#39;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">feat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">))]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">feat</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Creating sparse COO matrix&#39;</span><span class="p">)</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Converting to specified format&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fmt</span><span class="o">==</span><span class="s1">&#39;scipy.csr&#39;</span><span class="p">:</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fmt</span><span class="o">==</span><span class="s1">&#39;numpy.dense&#39;</span><span class="p">:</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
            
            <span class="k">return</span> <span class="n">features</span>        

<div class="viewcode-block" id="Ontology.get_annotation_matrix"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_annotation_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_annotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a gene-by-term matrix as a scipy.sparse.coo_matrix</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert gene names to indices</span>
        <span class="n">gene_2_term</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes_index</span><span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">t_list</span><span class="p">)</span> 
                       <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="n">annotation_matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">gene_2_term</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">],</span>
             <span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">gene_2_term</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">],</span>
              <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_list</span> <span class="ow">in</span> <span class="n">gene_2_term</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">])),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)))</span>
        
        <span class="k">return</span> <span class="n">annotation_matrix</span></div>

<div class="viewcode-block" id="Ontology.summary"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a summary of the Ontology&#39;s contents.&quot;&quot;&quot;</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> genes, &#39;</span>
                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> terms, &#39;</span>
                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> gene-term relations, &#39;</span>
                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> term-term relations&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">),</span>
                     <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">),</span>
                     <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_2_term</span><span class="o">.</span><span class="n">values</span><span class="p">()]),</span>
                     <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_2_child</span><span class="o">.</span><span class="n">values</span><span class="p">()])))</span>
        <span class="k">return</span> <span class="n">summary</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Ontology.run_clixo"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.run_clixo">[docs]</a>    <span class="k">def</span> <span class="nf">run_clixo</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span>
                  <span class="n">graph</span><span class="p">,</span>
                  <span class="n">alpha</span><span class="p">,</span>
                  <span class="n">beta</span><span class="p">,</span>
                  <span class="n">min_dt</span><span class="o">=-</span><span class="mi">10000000</span><span class="p">,</span>
                  <span class="n">timeout</span><span class="o">=</span><span class="mi">100000000</span><span class="p">,</span>
                  <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">output_log</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs the CLIXO algorithm and returns the result as an Ontology object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        graph</span>
<span class="sd">           3-column pandas.DataFrame</span>

<span class="sd">        alpha</span>
<span class="sd">           CLIXO alpha parameter</span>

<span class="sd">        beta</span>
<span class="sd">           CLIXO beta parameter</span>

<span class="sd">        min_dt</span>
<span class="sd">           Minimum similarity score</span>

<span class="sd">        timeout</span>
<span class="sd">           Maximum time (in seconds) allowed to run CLIXO</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        : ddot.Ontology.Ontology</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rerun</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output_file</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;temp output:&#39;</span><span class="p">,</span> <span class="n">output</span>
            <span class="n">rerun</span><span class="p">,</span> <span class="n">delete_output</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">graph</span><span class="p">)):</span>
            <span class="c1"># Write graph into a temporary file.</span>
            <span class="c1"># Assumes that &lt;graph&gt; is a list of 3-tuples (parent, child, score)</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">graph_file</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">graph</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">graph_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">graph_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">graph_file</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;temp graph:&#39;</span><span class="p">,</span> <span class="n">graph</span>
            <span class="n">rerun</span><span class="p">,</span> <span class="n">delete_graph</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">output_log</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_log</span><span class="p">)):</span>
            <span class="n">output_log_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">output_log</span> <span class="o">=</span> <span class="n">output_log_file</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;temp output log:&#39;</span><span class="p">,</span> <span class="n">output_log</span>
            <span class="n">rerun</span><span class="p">,</span> <span class="n">delete_output_log</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">rerun</span><span class="p">:</span>            
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">run_clixo</span><span class="p">(</span>
                    <span class="n">graph</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                    <span class="n">min_dt</span><span class="o">=</span><span class="n">min_dt</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
                    <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
                    <span class="n">output_log</span><span class="o">=</span><span class="n">output_log</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delete_output</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">delete_output_log</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">output_log</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">delete_graph</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="n">graph</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">min_dt</span><span class="p">])))</span>
        
        <span class="n">top_level</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">ddot</span><span class="p">)))</span>
        <span class="n">clixo_cmd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">top_level</span><span class="p">,</span> <span class="s1">&#39;mhk7-clixo_0.3-cec3674&#39;</span><span class="p">,</span> <span class="s1">&#39;clixo&#39;</span><span class="p">)</span>

        <span class="c1"># For timestamping everyline: awk &#39;{ print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;), $0; fflush(); }&#39;</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> </span><span class="si">{3}</span><span class="s2"> | awk&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clixo_cmd</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">+</span> 
               <span class="sd">&quot;&quot;&quot; &#39;{if ( $1 ~ /^#/ ) {print &quot;\#&quot;, strftime(&quot;%Y-%m-%d %H:%M:%S&quot;), $0 ; fflush() } else {print $0}}&#39;&quot;&quot;&quot;</span> <span class="o">+</span> 
               <span class="sd">&quot;&quot;&quot; | tee {}&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_log</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;CLIXO command:&#39;</span><span class="p">,</span> <span class="n">cmd</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">STDOUT</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># p = Popen(shlex.split(cmd), shell=False, stdout=PIPE, stderr=STDOUT, bufsize=1)</span>

        <span class="c1"># p_cmd = &quot;{0} {1} {2} {3} | awk&quot;&quot;&quot;.format(clixo_cmd, graph, alpha, beta)</span>
        <span class="c1"># p2_cmd = &quot;&quot;&quot;awk &#39;{if ( $1 ~ /^#/ ) {print &quot;\#&quot;, strftime(&quot;%Y-%m-%d %H:%M:%S&quot;), $0 ; fflush() } else {print $0}}&#39;&quot;&quot;&quot;</span>
        <span class="c1"># print &#39;CLIXO command:&#39;, cmd</span>

        <span class="n">curr_dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Asynchronous readout of the command&#39;s output</span>
        <span class="k">while</span> <span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Break if passed the maximum processing time</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">timeout</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">time_print</span><span class="p">(</span>
                        <span class="p">(</span><span class="s1">&#39;Killing process </span><span class="si">%s</span><span class="s1"> (OUT OF TIME). &#39;</span>
                         <span class="s1">&#39;Current dt: </span><span class="si">%s</span><span class="s1">: Output: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">curr_dt</span><span class="p">,</span> <span class="n">output_log</span><span class="p">))</span>
                <span class="k">break</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

            <span class="c1"># Remove newline character</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Break if the min_dt has been met</span>
            <span class="k">if</span> <span class="s1">&#39;# dt: &#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">curr_dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;# dt: &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">curr_dt</span> <span class="o">&lt;</span> <span class="n">min_dt</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">time_print</span><span class="p">(</span>
                            <span class="p">(</span><span class="s1">&#39;Killing process </span><span class="si">%s</span><span class="s1"> (BEYOND MIN THRESHOLD). &#39;</span>
                             <span class="s1">&#39;Current dt: </span><span class="si">%s</span><span class="s1">, min_dt: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">curr_dt</span><span class="p">,</span> <span class="n">min_dt</span><span class="p">))</span>
                    <span class="k">break</span>

            <span class="c1"># If line was empty, then sleep a bit</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>  <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Killing process </span><span class="si">%s</span><span class="s1">. Output: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">output_log</span><span class="p">))</span>
            <span class="n">p</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>  <span class="c1"># Kill the process</span>

            <span class="c1"># Extract ontology with extractOnt</span>
            <span class="n">p_ext</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> 0 0 </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">extract_cmd</span><span class="p">,</span> <span class="n">output_log</span><span class="p">,</span> <span class="n">output</span><span class="p">),</span>
                          <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">STDOUT</span><span class="p">)</span>
            <span class="n">p_ext</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Extracting by grep -v #&#39;</span><span class="p">)</span>

            <span class="c1"># Extract ontology with grep -v &#39;#&#39;</span>
            <span class="n">p_ext</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="s2">&quot;grep -v &#39;#&#39; </span><span class="si">%s</span><span class="s2"> | grep -v &#39;@&#39; &gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output_log</span><span class="p">,</span> <span class="n">output</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p_ext</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Elapsed time (sec): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
        
        <span class="n">ont</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_table</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">ont</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">term_prefix</span><span class="o">=</span><span class="s1">&#39;CLIXO:&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ont</span></div>

<div class="viewcode-block" id="Ontology.to_NdexGraph"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.to_NdexGraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_NdexGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">term_2_uuid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">represents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">gene_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">term_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">gene_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">term_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Formats an Ontology object into a NetworkX object with extra node</span>
<span class="sd">        attributes that are accessed by the hierarchical viewer.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert to NetworkX</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">(</span><span class="n">gene_attr</span><span class="o">=</span><span class="n">gene_attr</span><span class="p">,</span>
                             <span class="n">term_attr</span><span class="o">=</span><span class="n">term_attr</span><span class="p">,</span>
                             <span class="n">spanning_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">set_term_label</span> <span class="o">=</span> <span class="n">term_attr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;Label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">term_attr</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">set_gene_label</span> <span class="o">=</span> <span class="n">gene_attr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;Label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gene_attr</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>        
            <span class="k">if</span> <span class="n">set_term_label</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;Label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">term_prefix</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">represents</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;represents&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">term_2_uuid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;ndex:internalLink&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">](</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;Label&#39;</span><span class="p">],</span> <span class="n">term_2_uuid</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">set_gene_label</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="s1">&#39;Label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gene_prefix</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx_to_NdexGraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">set_network_attribute</span><span class="p">(</span><span class="s1">&#39;Description&#39;</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

    <span class="k">def</span> <span class="nf">_force_directed_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Force-directed layout on only the terms&quot;&quot;&quot;</span>

        <span class="n">sub_nx</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sub_nx</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">attr</span> <span class="ow">in</span> <span class="n">sub_nx</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="s1">&#39;Is_Tree_Edge&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Not_Tree&#39;</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">sub_nx</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                               <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">tmp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">tmp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="n">x_scale</span> <span class="o">=</span> <span class="mf">500.</span> <span class="o">/</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span>
        <span class="n">y_scale</span> <span class="o">=</span> <span class="mf">500.</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="p">:</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pos</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">pos</span>

<div class="viewcode-block" id="Ontology.upload_subnets_ndex"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.upload_subnets_ndex">[docs]</a>    <span class="k">def</span> <span class="nf">upload_subnets_ndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">sim</span><span class="p">,</span>
                            <span class="n">features</span><span class="p">,</span>
                            <span class="n">ndex_server</span><span class="p">,</span>
                            <span class="n">ndex_user</span><span class="p">,</span>
                            <span class="n">ndex_pass</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">gene_columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Gene1&#39;</span><span class="p">,</span> <span class="s1">&#39;Gene2&#39;</span><span class="p">],</span>
                            <span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">public</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">gene_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Push subnetworks to NDEx&quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">ndex.client</span> <span class="k">as</span> <span class="nn">nc</span>
        <span class="kn">from</span> <span class="nn">ndex.networkn</span> <span class="k">import</span> <span class="n">NdexGraph</span>

        <span class="k">if</span> <span class="n">propagate</span><span class="p">:</span>
            <span class="n">ontology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ontology</span><span class="o">.</span><span class="n">propagate_annotations</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ontology</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">ndex</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">Ndex</span><span class="p">(</span><span class="n">ndex_server</span><span class="p">,</span> <span class="n">ndex_user</span><span class="p">,</span> <span class="n">ndex_pass</span><span class="p">)</span>
        <span class="n">term_2_uuid</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">gene_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_lex&#39;</span><span class="p">,</span> <span class="n">gene_columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_lex&#39;</span>

        <span class="nb">print</span> <span class="s1">&#39;features:&#39;</span><span class="p">,</span> <span class="n">features</span>
        <span class="nb">print</span> <span class="s1">&#39;gene_columns:&#39;</span><span class="p">,</span> <span class="n">gene_columns</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">features</span> <span class="o">+</span> <span class="n">gene_columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Filter dataframe for gene pairs within the ontology</span>
        <span class="n">genes_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ontology</span><span class="o">.</span><span class="n">genes</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="ow">in</span> <span class="n">genes_set</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">genes_set</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">gene_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sim</span><span class="p">[</span><span class="n">gene_columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">sim</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Lexicographically sort gene1 and gene2 so that gene1 &lt; gene2</span>
        <span class="n">sim</span><span class="p">[</span><span class="n">g1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">gene_columns</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sim</span><span class="p">[</span><span class="n">g2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">gene_columns</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sim_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">g1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">g2</span><span class="p">]))}</span>

        <span class="nb">print</span> <span class="s1">&#39;Setup time:&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

        <span class="c1"># Normalize features into z-scores</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">features</span><span class="p">]</span>
        <span class="n">sim</span><span class="p">[</span><span class="n">features</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">tmp</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

        <span class="c1"># Calculate the min/max range of features</span>
        <span class="n">feature_mins</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">feature_maxs</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ontology</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="n">genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ontology</span><span class="o">.</span><span class="n">genes</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">ontology</span><span class="o">.</span><span class="n">term_2_genes</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span>
            <span class="n">genes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">gene_pairs_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim_idx</span><span class="p">[</span><span class="n">gp</span><span class="p">]</span> <span class="k">for</span> <span class="n">gp</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> \
                              <span class="k">if</span> <span class="n">sim_idx</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">gp</span><span class="p">)]</span>

            <span class="n">G_nx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_dataframe</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">gene_pairs_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span>
                                            <span class="n">edge_attr</span><span class="o">=</span><span class="n">features</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gene_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">set_node_attributes_from_pandas</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">gene_attr</span><span class="p">)</span>

            <span class="n">G</span> <span class="o">=</span> <span class="n">nx_to_NdexGraph</span><span class="p">(</span><span class="n">G_nx</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> supporting network for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">set_network_attribute</span><span class="p">(</span><span class="s1">&#39;Description&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> supporting network for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">set_network_attribute</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> min&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="n">feature_mins</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
                <span class="n">G</span><span class="o">.</span><span class="n">set_network_attribute</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> max&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="n">feature_maxs</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

            <span class="n">start_upload</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">ndex_url</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">upload_to</span><span class="p">(</span><span class="n">ndex_server</span><span class="p">,</span> <span class="n">ndex_user</span><span class="p">,</span> <span class="n">ndex_pass</span><span class="p">)</span>
            <span class="n">term_2_uuid</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">parse_ndex_uuid</span><span class="p">(</span><span class="n">ndex_url</span><span class="p">)</span>
            <span class="n">upload_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_upload</span>

            <span class="k">if</span> <span class="n">public</span><span class="p">:</span>
                <span class="n">ndex_uuid</span> <span class="o">=</span> <span class="n">parse_ndex_uuid</span><span class="p">(</span><span class="n">ndex_url</span><span class="p">)</span>
                <span class="n">ndex</span><span class="o">.</span><span class="n">make_network_public</span><span class="p">(</span><span class="n">ndex_uuid</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ontology</span><span class="o">.</span><span class="n">terms_index</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                      <span class="s1">&#39;Term:&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                      <span class="s1">&#39;Gene pairs:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_pairs_idx</span><span class="p">),</span>
                      <span class="s1">&#39;Genes:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">),</span>
                      <span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                      <span class="s1">&#39;Upload time:&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">upload_time</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">term_2_uuid</span></div>

<div class="viewcode-block" id="Ontology.get_best_ancestor_matrix"><a class="viewcode-back" href="../../ontology.html#ddot.Ontology.Ontology.get_best_ancestor_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_best_ancestor_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute common ancestor matrix.</span>

<span class="sd">        lca[a,b] = index of least common ancestor of terms a and b</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">node_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By default, sort from smallest to largest terms</span>
            <span class="n">node_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_term_sizes</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)))</span>

        <span class="n">ancestor_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ancestor_matrix</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">time_print</span><span class="p">(</span><span class="s1">&#39;Iterating:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_order</span><span class="p">):</span>

            <span class="c1"># Note: includes self as a child</span>
            <span class="n">children_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># For those descendants without a computed LCA yet, set their LCA to this term</span>
            <span class="n">lca_sub</span> <span class="o">=</span> <span class="n">ancestor_matrix</span><span class="p">[</span><span class="n">children_list</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">children_list</span><span class="p">]</span>
            <span class="n">lca_sub</span><span class="p">[</span><span class="n">lca_sub</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ancestor_matrix</span><span class="p">[</span><span class="n">children_list</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">children_list</span><span class="p">]</span> <span class="o">=</span> <span class="n">lca_sub</span>

        <span class="c1"># Check symmetry</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">ancestor_matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">ancestor_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ancestor_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The ontology may have more than one root&#39;</span>

        <span class="k">return</span> <span class="n">ancestor_matrix</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_make_tree_igraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;priority&#39;</span><span class="p">,</span>
                          <span class="n">edge_name</span><span class="o">=</span><span class="s1">&#39;smallest_parent&#39;</span><span class="p">,</span>
                          <span class="n">parent_priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns copy of graph with new edge attribute marking spanning</span>
<span class="sd">        tree&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_igraph</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;priority&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="n">parent_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">edge_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>            
            <span class="k">if</span> <span class="n">edge_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">assert</span> <span class="n">default_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">optim</span><span class="o">==</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">optim</span><span class="o">=</span><span class="nb">min</span>
            <span class="k">if</span> <span class="n">optim</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">optim</span><span class="o">=</span><span class="nb">max</span>

            <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">edge_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">:</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="sd">&quot;&quot;&quot;Choose the parent with the highest valued priority&quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">parent_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">small_parent</span> <span class="o">=</span> <span class="n">optim</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">parent_priority</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">edge_priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">small_parent</span> <span class="o">=</span> <span class="n">optim</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">edge_priority</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">default_priority</span><span class="p">))</span>

                    <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">small_parent</span><span class="p">)][</span><span class="n">edge_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Method not supported&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">collapse_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">g</span><span class="p">,</span>
                      <span class="n">v</span><span class="p">,</span>
                      <span class="n">edge_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">use_v_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">combine_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">default_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">fast_collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">use_v_name</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">unicode</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name_eq</span><span class="o">=</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">fast_collapse</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># A faster collapse that adds all new edges simultaneously. Ignores edge attributes        </span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parents</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_eids</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">incident</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)]</span>
            <span class="n">out_edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">incident</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">edge_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">in_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">in_edges</span> <span class="k">if</span> <span class="n">edge_filter</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span>
                <span class="n">out_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">out_edges</span> <span class="k">if</span> <span class="n">edge_filter</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">e_in</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e_out</span> <span class="ow">in</span> <span class="n">out_edges</span><span class="p">:</span>

                    <span class="n">in_neigh</span><span class="p">,</span> <span class="n">out_neigh</span> <span class="o">=</span> <span class="n">e_in</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">e_out</span><span class="o">.</span><span class="n">target</span>

                    <span class="c1"># Only add an edge if it doesn&#39;t already exist                                                                                                                   </span>
                    <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="n">in_neigh</span><span class="p">,</span> <span class="n">out_neigh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">in_neigh</span><span class="p">,</span> <span class="n">out_neigh</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">in_neigh</span><span class="p">,</span> <span class="n">out_neigh</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">combine_attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># Set default value of edge attributes to 0                                                                                                              </span>
                            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">combine_attrs</span><span class="p">:</span>  <span class="n">e</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="n">in_neigh</span><span class="p">,</span> <span class="n">out_neigh</span><span class="p">)]</span>

                    <span class="c1"># Update attributes                                                                                                                                              </span>
                    <span class="k">if</span> <span class="n">combine_attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">combine_attrs</span><span class="p">:</span>
                            <span class="n">e</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">combine_attrs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">e_in</span><span class="p">,</span> <span class="n">e_out</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">key</span><span class="o">==</span><span class="s1">&#39;triangle_edge_priority&#39;</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting&#39;</span><span class="p">,</span>
                                      <span class="n">key</span><span class="p">,</span>
                                      <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">in_neigh</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                      <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">out_neigh</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                      <span class="s1">&#39;to&#39;</span><span class="p">,</span>
                                      <span class="n">combine_attrs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">e_in</span><span class="p">,</span> <span class="n">e_out</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
                                      <span class="p">(</span><span class="n">e_in</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">e_out</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

                    <span class="n">e</span><span class="p">[</span><span class="s1">&#39;collapsed_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_in</span><span class="p">[</span><span class="s1">&#39;collapsed_length&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">e_out</span><span class="p">[</span><span class="s1">&#39;collapsed_length&#39;</span><span class="p">]</span>
                    <span class="n">e</span><span class="p">[</span><span class="s1">&#39;collapsed_terms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_in</span><span class="p">[</span><span class="s1">&#39;collapsed_terms&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">e_out</span><span class="p">[</span><span class="s1">&#39;collapsed_terms&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">delete</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span></div>

    <span class="c1"># def map_gene_pairs_2_triangles(self, gsets):</span>
    <span class="c1">#     &quot;&quot;&quot;Assign each gene pair to it&#39;s smallest common ancestor.  This is</span>
    <span class="c1">#     it&#39;s &#39;triangle&#39;.  It also works out that this is both of their</span>
    <span class="c1">#     lowest terms, such that this is like a within-term</span>
    <span class="c1">#     interaction&quot;&quot;&quot;</span>

    <span class="c1">#     ontology = self</span>

    <span class="c1">#     graph_orig = ontology.to_igraph()</span>
    <span class="c1">#     graph = ontology.to_igraph().copy()</span>
    <span class="c1">#     graph.add_vertices(ontology.genes)</span>
    <span class="c1">#     assert graph.vs[-len(ontology.genes):][&#39;name&#39;] == ontology.genes</span>
    <span class="c1">#     assert graph.vs[:len(ontology.terms)][&#39;name&#39;] == ontology.terms</span>
    <span class="c1">#     graph.add_edges([(g, t) for g, terms in [(len(ontology.terms) + ontology.genes_index[g], terms) for g, terms in ontology.gene_2_term.items()] for t in terms])</span>
    <span class="c1">#     gene_sca_matrix = get_smallest_ancestor(graph, ontology.get_term_sizes().tolist() + [1 for i in ontology.genes], verbose=True)</span>
    <span class="c1">#     term_2_genes = {ontology.terms_index[t] : set(g) for t, g in ontology.get_term_2_genes().items()}</span>

    <span class="c1">#     # tmp = [(i, j, gene_sca_matrix[len(ontology.terms) + i, len(ontology.terms) + j], graph_orig.neighbors(gene_sca_matrix[len(ontology.terms) + i, len(ontology.terms) + j], mode=&#39;in&#39;)) for i, j in [(ontology.genes_index[g1], ontology.genes_index[g2]) for g1, g2 in gsets]]</span>
    <span class="c1">#     # triangles = [(sca, [t for t in terms if i in term_2_genes[t]], [t for t in terms if j in term_2_genes[t]]) for i, j, sca, terms in tmp]</span>

    <span class="c1">#     #--- Alternate triangle calculation.  Allow for multiple SCA in anti-chain paths</span>
    <span class="c1">#     # Make sure the order is &#39;C&#39;.  Set the diagonal to True (even though it should technically be False) for easier use of np.all below</span>
    <span class="c1">#     connectivity = ontology.get_connectivity_matrix()</span>
    <span class="c1">#     not_connectivity = np.logical_not(np.array(connectivity, dtype=np.bool, order=&#39;C&#39;))</span>
    <span class="c1">#     np.fill_diagonal(not_connectivity, True)</span>

    <span class="c1">#     children_dict = {v.index : np.array(graph_orig.neighbors(v.index, mode=&#39;in&#39;)) for v in graph_orig.vs}</span>
    <span class="c1">#     gene_2_term_set = {g : np.array(terms) for g, terms in ontology.gene_2_term.items()}</span>
    <span class="c1">#     term_2_genes = {ontology.terms_index[t] : set(g) for t, g in ontology.get_term_2_genes().items()}</span>

    <span class="c1">#     time_print(&#39;Calculating triangles&#39;)</span>
    <span class="c1">#     triangles = ((g1, g2, gene_2_term_set[g1], gene_2_term_set[g2]) for g1, g2 in gsets)</span>
    <span class="c1">#     triangles = ((g1, g2, g1_terms, g2_terms, np.intersect1d(g1_terms, g2_terms, assume_unique=True)) for g1, g2, g1_terms, g2_terms in triangles)</span>
    <span class="c1">#     # This could be potentially double-counting a term pair if for a single gene pair, they have more than one sca</span>
    <span class="c1">#     # triangles = [[(sca, np.intersect1d(g1_terms, children_dict[sca], assume_unique=True), np.intersect1d(g2_terms, children_dict[sca], assume_unique=True)) for sca in terms[not_connectivity[terms, :][:, terms].all(axis=0)]] for g1, g2, g1_terms, g2_terms, terms in triangles]</span>
    <span class="c1">#     triangles = [[(sca,</span>
    <span class="c1">#                    tuple(np.intersect1d(g1_terms, children_dict[sca], assume_unique=True)),</span>
    <span class="c1">#                    tuple(np.intersect1d(g2_terms, children_dict[sca], assume_unique=True))) \</span>
    <span class="c1">#                       for sca in terms[not_connectivity[terms, :][:, terms].all(axis=0)]] \</span>
    <span class="c1">#                  for g1, g2, g1_terms, g2_terms, terms in triangles]</span>

    <span class="c1">#     ## Each element corresponds to a gene pair.  Each element is a</span>
    <span class="c1">#     ## list of triplets (LCA, children terms spanned by gene 1,</span>
    <span class="c1">#     ## children terms spanned by gene 2)</span>
    <span class="c1">#     return triangles</span>

    <span class="c1"># def count_siblings(triangles, num_terms, term_pair_triangles=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Returns the number of times that a sibling occurs in a set of triangles&quot;&quot;&quot;</span>

    <span class="c1">#     triu_indices = np.triu_indices(num_terms, k=1)</span>

    <span class="c1">#     if term_pair_triangles is None:</span>
    <span class="c1">#         term_pair_triangles = [set([ (t1, t2) if t1 &lt; t2 else (t2, t1) for sca, side1, side2 in path for t1 in side1 for t2 in side2]) \</span>
    <span class="c1">#                                for path in triangles]</span>

    <span class="c1">#     return scipy.sparse.coo_matrix(([1 for term_pairs in term_pair_triangles for t1, t2 in term_pairs],</span>
    <span class="c1">#                                     ([t1 for term_pairs in term_pair_triangles for t1, t2 in term_pairs],</span>
    <span class="c1">#                                      ([t2 for term_pairs in term_pair_triangles for t1, t2 in term_pairs]))),</span>
    <span class="c1">#                                    shape=(num_terms, num_terms)).toarray()[triu_indices]</span>


    <span class="c1"># def siblings_2_gene_pairs(triangles):</span>
    <span class="c1">#     &quot;&quot;&quot;Returns dictionary mapping a sibling (t1, t2), where the term</span>
    <span class="c1"># indices are t1&lt;t2, to the indices of gene pairs.  This is the same as</span>
    <span class="c1"># indices to elements in &lt;triangles&gt;&quot;&quot;&quot;</span>

    <span class="c1">#     return {a : [y for x, y in b] for a, b in groupby(sorted([((t1, t2) if t1&lt;t2 else (t2, t1), i) for i, tri in enumerate(triangles) for \</span>
    <span class="c1">#                                                               sca, t1_list, t2_list in tri for t1 in t1_list for t2 in t2_list],</span>
    <span class="c1">#                                                              key=lambda a:a[0]), key=lambda a:a[0])}</span>
    <span class="c1"># def lcas_2_gene_pairs(triangles):</span>
    <span class="c1">#     &quot;&quot;&quot;Returns dictionary mapping a term to the indices of gene pairs.</span>
    <span class="c1"># This is the same as indices to elements in &lt;triangles&gt; &quot;&quot;&quot;</span>

    <span class="c1">#     return {a : [y for x, y in b] for a, b in groupby(sorted([(sca, i) for i, tri in enumerate(triangles) for \</span>
    <span class="c1">#                                                                 sca, t1_list, t2_list in tri],</span>
    <span class="c1">#                                                                key=lambda a:a[0]), key=lambda a:a[0])}</span>

    <span class="c1"># def explain_gene_pairs(triangles, lcas, siblings):</span>
    <span class="c1">#     &quot;&quot;&quot;Given a list of enriched siblings and lcas, returns those siblings</span>
    <span class="c1"># and lcas that a gene pair falls under.</span>

    <span class="c1">#     For each element in triangles, returns a pair (x, y) where x are</span>
    <span class="c1">#     terms in lcas and y are term pairs in siblings.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     lcas, siblings = set(lcas), set([(t1,t2) if t1&lt;t2 else (t2, t1) for t1, t2 in siblings])</span>
    <span class="c1">#     return [(set([sca for sca, t1_list, t2_list in tri]) &amp; lcas,</span>
    <span class="c1">#              set([(t1,t2) if t1&lt;t2 else (t2,t1) for sca, t1_list, t2_list in tri for t1 in t1_list for t2 in t2_list])) \</span>
    <span class="c1">#             for tri in triangles]</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Ku Yu.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>